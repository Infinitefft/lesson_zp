# JS 语言工作的底层机制
    - v8 引擎
    - 调用栈
        - 编译阶段
        - 执行阶段
    - 执行上下文（底部全局，函数）
    - 作用域
        变量的查找范围和生命周期
        - 块级作用域 栈结构的词法环境
        - hoisting 变量提升 变得简单高效

## 作用域链
- 作用域链的查找规则？
    - 一定要知道
    - 作用域链 变量的查找路径
        按照函数声明的时候
- 为什么是全局作用域
    - 为什么不是foo()？
    函数在**调用栈**中的顺序 不是这样的

## 词法作用域 以及词法作用域链
词法作用域是由代码中函数声明的位置决定的
作用域链也叫**词法作用域链**，静态的，只和函数声明的位置相关，在编译阶段就
决定好了，和调用位置没有关系

## 闭包 closure 
无处不在的高级概念
静态的， 词法作用域后
- 函数运行的时候，也有一种情况
    就好像函数运行的时候不是在它声明的位置，作用域链

- 闭包基于词法作用域链的理解
- 形成条件是函数嵌套函数
- 被闭包的函数要在外部可以访问到 return
- 被闭包的函数执行的时候能找到定义它的时候的执行上下文中的变量

foo 函数执行完后，其执行上下文从栈顶弹出了，但是由于返回的setName，
getName 使用了foo 函数内部的变量 myName 和 test1，这两个变量依然在
内存中，有点像给getName, setName 方法背的一个专属背包。
这个背包闭包，这个闭包里面的变量叫自由变量